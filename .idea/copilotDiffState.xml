<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle" />
              <option name="originalContent" value="plugins {&#10;&#9;id 'java'&#10;&#9;id 'org.springframework.boot' version '3.5.6'&#10;&#9;id 'io.spring.dependency-management' version '1.1.7'&#10;}&#10;&#10;group = 'com.restaurant'&#10;version = '0.0.1-SNAPSHOT'&#10;description = 'Restaurant App'&#10;&#10;java {&#10;&#9;toolchain {&#10;&#9;&#9;languageVersion = JavaLanguageVersion.of(21)&#10;&#9;}&#10;}&#10;&#10;configurations {&#10;&#9;compileOnly {&#10;&#9;&#9;extendsFrom annotationProcessor&#10;&#9;}&#10;}&#10;&#10;repositories {&#10;&#9;mavenCentral()&#10;}&#10;&#10;dependencies {&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-actuator'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-data-elasticsearch'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-data-jpa'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-data-redis'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-data-redis-reactive'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-security'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-validation'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-web'&#10;&#9;implementation 'org.apache.kafka:kafka-streams'&#10;&#9;implementation 'org.springframework.kafka:spring-kafka'&#10;&#9;implementation 'org.springframework.session:spring-session-data-mongodb'&#10;&#9;implementation 'org.springframework.session:spring-session-data-redis'&#10;&#9;implementation 'org.springframework.session:spring-session-jdbc'&#10;&#9;compileOnly 'org.projectlombok:lombok'&#10;&#9;developmentOnly 'org.springframework.boot:spring-boot-devtools'&#10;&#9;annotationProcessor 'org.projectlombok:lombok'&#10;&#9;testImplementation 'org.springframework.boot:spring-boot-starter-test'&#10;&#9;testImplementation 'io.projectreactor:reactor-test'&#10;&#9;testImplementation 'org.springframework.kafka:spring-kafka-test'&#10;&#9;testImplementation 'org.springframework.security:spring-security-test'&#10;&#9;testRuntimeOnly 'org.junit.platform:junit-platform-launcher'&#10;    runtimeOnly   'org.postgresql:postgresql'&#10;}&#10;&#10;tasks.named('bootBuildImage') {&#10;&#9;runImage = 'paketobuildpacks/ubuntu-noble-run-base:latest'&#10;}&#10;&#10;tasks.named('test') {&#10;&#9;useJUnitPlatform()&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;&#9;id 'java'&#10;&#9;id 'org.springframework.boot' version '3.5.6'&#10;&#9;id 'io.spring.dependency-management' version '1.1.7'&#10;}&#10;&#10;group = 'com.restaurant'&#10;version = '0.0.1-SNAPSHOT'&#10;description = 'Restaurant App'&#10;&#10;java {&#10;&#9;toolchain {&#10;&#9;&#9;languageVersion = JavaLanguageVersion.of(21)&#10;&#9;}&#10;}&#10;&#10;configurations {&#10;&#9;compileOnly {&#10;&#9;&#9;extendsFrom annotationProcessor&#10;&#9;}&#10;}&#10;&#10;repositories {&#10;&#9;mavenCentral()&#10;}&#10;&#10;dependencies {&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-actuator'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-data-jpa'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-security'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-validation'&#10;&#9;implementation 'org.springframework.boot:spring-boot-starter-web'&#10;&#9;&#10;&#9;compileOnly 'org.projectlombok:lombok'&#10;&#9;developmentOnly 'org.springframework.boot:spring-boot-devtools'&#10;&#9;runtimeOnly 'org.postgresql:postgresql'&#10;&#9;annotationProcessor 'org.projectlombok:lombok'&#10;&#9;&#10;&#9;testImplementation 'org.springframework.boot:spring-boot-starter-test'&#10;&#9;testImplementation 'org.springframework.security:spring-security-test'&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.restaurant.Apollo.Auth.config;&#10;&#10;import com.restaurant.Apollo.Auth.filters.TokenAuthFilter;&#10;import com.restaurant.Apollo.Auth.service.TokenService;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;&#10;@Configuration&#10;public class SecurityConfig {&#10;&#10;    private final TokenService tokenService;&#10;&#10;    public SecurityConfig(TokenService tokenService) {&#10;        this.tokenService = tokenService;&#10;    }&#10;&#10;    @Bean&#10;    PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    @Bean&#10;    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .csrf(csrf -&gt; csrf.disable())&#10;                .sessionManagement(sm -&gt; sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        .requestMatchers(&quot;/api/auth/**&quot;).permitAll()&#10;                        .requestMatchers(HttpMethod.GET, &quot;/api/public/**&quot;).permitAll()&#10;                        .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                        .anyRequest().authenticated()&#10;                )&#10;                .addFilterBefore(new TokenAuthFilter(tokenService), UsernamePasswordAuthenticationFilter.class)&#10;                .exceptionHandling(ex -&gt; ex&#10;                    .authenticationEntryPoint((request, response, authException) -&gt; {&#10;                        response.setStatus(HttpStatus.UNAUTHORIZED.value());&#10;                        response.getWriter().write(&quot;Unauthorized - Invalid or missing token&quot;);&#10;                    })&#10;                    .accessDeniedHandler((request, response, accessDeniedException) -&gt; {&#10;                        response.setStatus(HttpStatus.FORBIDDEN.value());&#10;                        response.getWriter().write(&quot;Access Denied - Insufficient permissions&quot;);&#10;                    })&#10;                );&#10;&#10;        return http.build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.restaurant.Apollo.Auth.config;&#10;&#10;import com.restaurant.Apollo.Auth.filters.TokenAuthFilter;&#10;import com.restaurant.Apollo.Auth.service.TokenService;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.Arrays;&#10;&#10;@Configuration&#10;public class SecurityConfig {&#10;&#10;    private final TokenService tokenService;&#10;&#10;    public SecurityConfig(TokenService tokenService) {&#10;        this.tokenService = tokenService;&#10;    }&#10;&#10;    @Bean&#10;    PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    @Bean&#10;    CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:5173&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));&#10;        configuration.setAllowedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;));&#10;        configuration.setAllowCredentials(true);&#10;&#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;                .csrf(csrf -&gt; csrf.disable())&#10;                .sessionManagement(sm -&gt; sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        .requestMatchers(&quot;/api/auth/**&quot;).permitAll()&#10;                        .requestMatchers(HttpMethod.GET, &quot;/api/public/**&quot;).permitAll()&#10;                        .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                        .anyRequest().authenticated()&#10;                )&#10;                .addFilterBefore(new TokenAuthFilter(tokenService), UsernamePasswordAuthenticationFilter.class)&#10;                .exceptionHandling(ex -&gt; ex&#10;                    .authenticationEntryPoint((request, response, authException) -&gt; {&#10;                        response.setStatus(HttpStatus.UNAUTHORIZED.value());&#10;                        response.getWriter().write(&quot;Unauthorized - Invalid or missing token&quot;);&#10;                    })&#10;                    .accessDeniedHandler((request, response, accessDeniedException) -&gt; {&#10;                        response.setStatus(HttpStatus.FORBIDDEN.value());&#10;                        response.getWriter().write(&quot;Access Denied - Insufficient permissions&quot;);&#10;                    })&#10;                );&#10;&#10;        return http.build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/filters/TokenAuthFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/filters/TokenAuthFilter.java" />
              <option name="originalContent" value="package com.restaurant.Apollo.Auth.filters;&#10;&#10;import com.restaurant.Apollo.Auth.service.TokenService;&#10;import com.restaurant.Apollo.UserManagement.model.User;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import org.springframework.security.authentication.AbstractAuthenticationToken;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import java.io.IOException;&#10;import java.util.stream.Collectors;&#10;&#10;public class TokenAuthFilter extends OncePerRequestFilter {&#10;&#10;    private final TokenService tokenService;&#10;&#10;    public TokenAuthFilter(TokenService tokenService) {&#10;        this.tokenService = tokenService;&#10;    }&#10;&#10;    @Override&#10;    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)&#10;            throws ServletException, IOException {&#10;&#10;        String auth = request.getHeader(&quot;Authorization&quot;);&#10;        if (auth != null &amp;&amp; auth.startsWith(&quot;Bearer &quot;)) {&#10;            String raw = auth.substring(7);&#10;            User user = tokenService.validate(raw);&#10;            if (user != null) {&#10;                var authorities = user.getRoles().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());&#10;                AbstractAuthenticationToken authentication =&#10;                        new AbstractAuthenticationToken(authorities) {&#10;                            @Override public Object getCredentials() { return raw; }&#10;                            @Override public Object getPrincipal() { return user.getEmail(); }&#10;                        };&#10;                authentication.setAuthenticated(true);&#10;                SecurityContextHolder.getContext().setAuthentication(authentication);&#10;            }&#10;        }&#10;        chain.doFilter(request, response);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.restaurant.Apollo.Auth.filters;&#10;&#10;import com.restaurant.Apollo.Auth.service.TokenService;&#10;import com.restaurant.Apollo.UserManagement.model.User;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import java.io.IOException;&#10;import java.util.Collections;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;&#10;public class TokenAuthFilter extends OncePerRequestFilter {&#10;&#10;    private final TokenService tokenService;&#10;&#10;    public TokenAuthFilter(TokenService tokenService) {&#10;        this.tokenService = tokenService;&#10;    }&#10;&#10;    @Override&#10;    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)&#10;            throws ServletException, IOException {&#10;&#10;        try {&#10;            String auth = request.getHeader(&quot;Authorization&quot;);&#10;            if (auth != null &amp;&amp; auth.startsWith(&quot;Bearer &quot;)) {&#10;                String raw = auth.substring(7);&#10;                User user = tokenService.validate(raw);&#10;                if (user != null) {&#10;                    Set&lt;SimpleGrantedAuthority&gt; authorities = user.getRoles() != null ?&#10;                            user.getRoles().stream()&#10;                                    .map(SimpleGrantedAuthority::new)&#10;                                    .collect(Collectors.toSet()) :&#10;                            Collections.emptySet();&#10;&#10;                    var authentication = new UsernamePasswordAuthenticationToken(&#10;                            user.getEmail(),    // principal&#10;                            null,               // credentials (null pentru că nu avem nevoie de ele după autentificare)&#10;                            authorities         // authorities&#10;                    );&#10;&#10;                    SecurityContextHolder.getContext().setAuthentication(authentication);&#10;                }&#10;            }&#10;        } catch (Exception ex) {&#10;            logger.error(&quot;Could not set user authentication&quot;, ex);&#10;        }&#10;&#10;        chain.doFilter(request, response);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/repository/AuthTokenRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/repository/AuthTokenRepository.java" />
              <option name="originalContent" value="package com.restaurant.Apollo.Auth.repository;&#10;&#10;import com.restaurant.Apollo.Auth.model.AuthToken;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Modifying;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.Instant;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface AuthTokenRepository extends JpaRepository&lt;AuthToken, Long&gt; {&#10;    Optional&lt;AuthToken&gt; findByTokenHashAndRevokedFalse(String tokenHash);&#10;&#10;    Optional&lt;AuthToken&gt; findByTokenHashAndRevokedFalseAndExpiresAtAfter(String tokenHash, Instant time);&#10;&#10;    long deleteByExpiresAtBefore(Instant time);&#10;&#10;    @Modifying&#10;    @Query(&quot;update AuthToken t set t.revoked = true &quot; +&#10;            &quot;where t.user.id = :userId and t.revoked = false&quot;)&#10;    int revokeAllActiveByUserId(@Param(&quot;userId&quot;) Long userId);&#10;}&#10;" />
              <option name="updatedContent" value="package com.restaurant.Apollo.Auth.repository;&#13;&#10;&#13;&#10;import com.restaurant.Apollo.Auth.model.AuthToken;&#13;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#13;&#10;import org.springframework.data.jpa.repository.Modifying;&#13;&#10;import org.springframework.data.jpa.repository.Query;&#13;&#10;import org.springframework.data.repository.query.Param;&#13;&#10;import org.springframework.stereotype.Repository;&#13;&#10;&#13;&#10;import java.time.Instant;&#13;&#10;import java.util.Optional;&#13;&#10;&#13;&#10;@Repository&#13;&#10;public interface AuthTokenRepository extends JpaRepository&lt;AuthToken, Long&gt; {&#13;&#10;    Optional&lt;AuthToken&gt; findByTokenHashAndRevokedFalse(String tokenHash);&#13;&#10;&#13;&#10;    Optional&lt;AuthToken&gt; findByTokenHashAndRevokedFalseAndExpiresAtAfter(String tokenHash, Instant time);&#13;&#10;&#13;&#10;    @Query(&quot;SELECT t FROM AuthToken t JOIN FETCH t.user u LEFT JOIN FETCH u.roles &quot; +&#13;&#10;            &quot;WHERE t.tokenHash = :hash AND t.revoked = false AND t.expiresAt &gt; :time&quot;)&#13;&#10;    Optional&lt;AuthToken&gt; findByTokenHashAndRevokedFalseAndExpiresAtAfterWithUser(&#13;&#10;            @Param(&quot;hash&quot;) String hash,&#13;&#10;            @Param(&quot;time&quot;) Instant time);&#13;&#10;&#13;&#10;    long deleteByExpiresAtBefore(Instant time);&#13;&#10;&#13;&#10;    @Modifying&#13;&#10;    @Query(&quot;update AuthToken t set t.revoked = true &quot; +&#13;&#10;            &quot;where t.user.id = :userId and t.revoked = false&quot;)&#13;&#10;    int revokeAllActiveByUserId(@Param(&quot;userId&quot;) Long userId);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/service/TokenService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/restaurant/Apollo/Auth/service/TokenService.java" />
              <option name="originalContent" value="package com.restaurant.Apollo.Auth.service;&#10;&#10;import com.restaurant.Apollo.Auth.model.AuthToken;&#10;import com.restaurant.Apollo.Auth.repository.AuthTokenRepository;&#10;import com.restaurant.Apollo.UserManagement.model.User;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.nio.charset.StandardCharsets;&#10;import java.security.SecureRandom;&#10;import java.time.Instant;&#10;import java.util.HexFormat;&#10;&#10;@Service&#10;public class TokenService {&#10;&#10;    private static final SecureRandom RNG = new SecureRandom();&#10;    @Autowired&#10;    private final AuthTokenRepository tokens;&#10;    private final long ttlMinutes;&#10;    private final boolean rotateOnLogin;&#10;&#10;    public TokenService(AuthTokenRepository tokens,&#10;                        @Value(&quot;${app.token.ttl-minutes}&quot;) long ttlMinutes,&#10;                        @Value(&quot;${app.token.rotate-on-login:false}&quot;) boolean rotateOnLogin) {&#10;        this.tokens = tokens;&#10;        this.ttlMinutes = ttlMinutes;&#10;        this.rotateOnLogin = rotateOnLogin;&#10;    }&#10;&#10;    public record GeneratedToken(String rawToken, long expiresInSeconds) {}&#10;&#10;    public GeneratedToken issue(User user) {&#10;        if (rotateOnLogin) revokeAllFor(user);&#10;&#10;        String raw = randomToken();&#10;        String hash = sha256(raw);&#10;        Instant now = Instant.now();&#10;        Instant exp = now.plusSeconds(ttlMinutes * 60);&#10;&#10;        AuthToken at = AuthToken.builder()&#10;                .tokenHash(hash)&#10;                .user(user)&#10;                .createdAt(now)&#10;                .expiresAt(exp)&#10;                .revoked(false)&#10;                .build();&#10;        tokens.save(at);&#10;&#10;        return new GeneratedToken(raw, ttlMinutes * 60);&#10;    }&#10;&#10;    public User validate(String rawToken) {&#10;        if (rawToken == null || rawToken.isBlank()) return null;&#10;        var hash = sha256(rawToken);&#10;        var opt = tokens.findByTokenHashAndRevokedFalse(hash);&#10;        if (opt.isEmpty()) return null;&#10;&#10;        var t = opt.get();&#10;        if (t.getExpiresAt().isBefore(Instant.now())) {&#10;            t.setRevoked(true);&#10;            tokens.save(t);&#10;            return null;&#10;        }&#10;        return t.getUser();&#10;    }&#10;&#10;    public void revoke(String rawToken) {&#10;        if (rawToken == null || rawToken.isBlank()) return;&#10;        tokens.findByTokenHashAndRevokedFalse(sha256(rawToken)).ifPresent(t -&gt; {&#10;            t.setRevoked(true);&#10;            tokens.save(t);&#10;        });&#10;    }&#10;&#10;    /**  Metoda care lipsea */&#10;    @Transactional&#10;    public int revokeAllFor(User user) {&#10;        if (user == null || user.getId() == null) return 0;&#10;        return tokens.revokeAllActiveByUserId(user.getId());&#10;    }&#10;&#10;    public long purgeExpired() {&#10;        return tokens.deleteByExpiresAtBefore(Instant.now());&#10;    }&#10;&#10;    private static String randomToken() {&#10;        byte[] buf = new byte[32]; // 256-bit&#10;        RNG.nextBytes(buf);&#10;        return HexFormat.of().formatHex(buf);&#10;    }&#10;&#10;    private static String sha256(String raw) {&#10;        try {&#10;            var md = java.security.MessageDigest.getInstance(&quot;SHA-256&quot;);&#10;            var out = md.digest(raw.getBytes(StandardCharsets.UTF_8));&#10;            return HexFormat.of().formatHex(out);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.restaurant.Apollo.Auth.service;&#13;&#10;&#13;&#10;import com.restaurant.Apollo.Auth.model.AuthToken;&#13;&#10;import com.restaurant.Apollo.Auth.repository.AuthTokenRepository;&#13;&#10;import com.restaurant.Apollo.UserManagement.model.User;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.beans.factory.annotation.Value;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.transaction.annotation.Transactional;&#13;&#10;&#13;&#10;import java.nio.charset.StandardCharsets;&#13;&#10;import java.security.SecureRandom;&#13;&#10;import java.time.Instant;&#13;&#10;import java.util.HexFormat;&#13;&#10;&#13;&#10;@Service&#13;&#10;public class TokenService {&#13;&#10;&#13;&#10;    private static final SecureRandom RNG = new SecureRandom();&#13;&#10;    @Autowired&#13;&#10;    private final AuthTokenRepository tokens;&#13;&#10;    private final long ttlMinutes;&#13;&#10;    private final boolean rotateOnLogin;&#13;&#10;&#13;&#10;    public TokenService(AuthTokenRepository tokens,&#13;&#10;                        @Value(&quot;${app.token.ttl-minutes}&quot;) long ttlMinutes,&#13;&#10;                        @Value(&quot;${app.token.rotate-on-login:false}&quot;) boolean rotateOnLogin) {&#13;&#10;        this.tokens = tokens;&#13;&#10;        this.ttlMinutes = ttlMinutes;&#13;&#10;        this.rotateOnLogin = rotateOnLogin;&#13;&#10;    }&#13;&#10;&#13;&#10;    public record GeneratedToken(String rawToken, long expiresInSeconds) {}&#13;&#10;&#13;&#10;    public GeneratedToken issue(User user) {&#13;&#10;        if (rotateOnLogin) revokeAllFor(user);&#13;&#10;&#13;&#10;        String raw = randomToken();&#13;&#10;        String hash = sha256(raw);&#13;&#10;        Instant now = Instant.now();&#13;&#10;        Instant exp = now.plusSeconds(ttlMinutes * 60);&#13;&#10;&#13;&#10;        AuthToken at = AuthToken.builder()&#13;&#10;                .tokenHash(hash)&#13;&#10;                .user(user)&#13;&#10;                .createdAt(now)&#13;&#10;                .expiresAt(exp)&#13;&#10;                .revoked(false)&#13;&#10;                .build();&#13;&#10;        tokens.save(at);&#13;&#10;&#13;&#10;        return new GeneratedToken(raw, ttlMinutes * 60);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public User validate(String rawToken) {&#13;&#10;        if (rawToken == null) return null;&#13;&#10;        String hash = sha256(rawToken);&#13;&#10;        return tokens.findByTokenHashAndRevokedFalseAndExpiresAtAfterWithUser(hash, Instant.now())&#13;&#10;                .map(AuthToken::getUser)&#13;&#10;                .orElse(null);&#13;&#10;    }&#13;&#10;&#13;&#10;    public void revoke(String rawToken) {&#13;&#10;        if (rawToken == null || rawToken.isBlank()) return;&#13;&#10;        tokens.findByTokenHashAndRevokedFalse(sha256(rawToken)).ifPresent(t -&gt; {&#13;&#10;            t.setRevoked(true);&#13;&#10;            tokens.save(t);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**  Metoda care lipsea */&#13;&#10;    @Transactional&#13;&#10;    public int revokeAllFor(User user) {&#13;&#10;        if (user == null || user.getId() == null) return 0;&#13;&#10;        return tokens.revokeAllActiveByUserId(user.getId());&#13;&#10;    }&#13;&#10;&#13;&#10;    public long purgeExpired() {&#13;&#10;        return tokens.deleteByExpiresAtBefore(Instant.now());&#13;&#10;    }&#13;&#10;&#13;&#10;    private static String randomToken() {&#13;&#10;        byte[] buf = new byte[32]; // 256-bit&#13;&#10;        RNG.nextBytes(buf);&#13;&#10;        return HexFormat.of().formatHex(buf);&#13;&#10;    }&#13;&#10;&#13;&#10;    private static String sha256(String raw) {&#13;&#10;        try {&#13;&#10;            var md = java.security.MessageDigest.getInstance(&quot;SHA-256&quot;);&#13;&#10;            var out = md.digest(raw.getBytes(StandardCharsets.UTF_8));&#13;&#10;            return HexFormat.of().formatHex(out);&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RuntimeException(e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application-docker.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application-docker.yml" />
              <option name="originalContent" value="spring:&#10;  datasource:&#10;    url: jdbc:postgresql://postgres:5432/restaurant&#10;    username: restaurant&#10;    password: restaurant&#10;    driver-class-name: org.postgresql.Driver&#10;&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: none&#10;    show-sql: true&#10;&#10;  sql:&#10;    init:&#10;      mode: never&#10;&#10;  security:&#10;    user:&#10;      name: admin&#10;      password: 1234&#10;&#10;app:&#10;  token:&#10;    issuer: &quot;restaurant-app&quot;&#10;    ttl-minutes: 30&#10;    rotate-on-login: false&#10;" />
              <option name="updatedContent" value="spring:&#10;  datasource:&#10;    url: jdbc:postgresql://postgres:5432/restaurant&#10;    username: restaurant&#10;    password: restaurant&#10;    driver-class-name: org.postgresql.Driver&#10;&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: none&#10;    show-sql: true&#10;    properties:&#10;      hibernate:&#10;        format_sql: true&#10;&#10;  sql:&#10;    init:&#10;      mode: never&#10;&#10;management:&#10;  health:&#10;    elasticsearch:&#10;      enabled: false&#10;    redis:&#10;      enabled: false&#10;    db:&#10;      enabled: true&#10;  endpoints:&#10;    web:&#10;      exposure:&#10;        include: health,info&#10;  endpoint:&#10;    health:&#10;      show-details: always&#10;&#10;app:&#10;  token:&#10;    issuer: &quot;restaurant-app&quot;&#10;    ttl-minutes: 30&#10;    rotate-on-login: false" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>